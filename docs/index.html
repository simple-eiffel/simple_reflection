<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simple_reflection - Simple Eiffel Library</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <header>
        <div class="container">
            <img src="images/logo.png" alt="simple_reflection" class="logo">
            <h1>simple_reflection</h1>
            <p class="tagline">Runtime reflection and type introspection for Eiffel</p>
            <div class="badges">
                <img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="MIT License">
                <img src="https://img.shields.io/badge/Eiffel-25.02-purple.svg" alt="Eiffel 25.02">
                <img src="https://img.shields.io/badge/DBC-Contracts-green.svg" alt="Design by Contract">
            </div>
        </div>
    </header>

    <nav>
        <div class="container">
            <a href="#overview">Overview</a>
            <a href="#quick-start">Quick Start</a>
            <a href="#features">Features</a>
            <a href="#api-reference">API Reference</a>
            <a href="https://github.com/simple-eiffel/simple_reflection">GitHub</a>
        </div>
    </nav>

    <main>
        <div class="container">
            <section id="overview">
                <h2>Overview</h2>
                <p>SIMPLE_REFLECTION provides runtime introspection capabilities for Eiffel applications, enabling inspection and manipulation of objects at runtime through a clean, contract-based API.</p>
                <p>The library wraps Eiffel's INTERNAL class with a higher-level abstraction, providing type-safe access to object fields, type metadata caching for performance, and support for type-safe enumerations and flags.</p>
                <p>Key use cases include serialization libraries, debugging tools, ORM implementations, and any scenario requiring dynamic object inspection without compile-time type knowledge.</p>
            </section>

            <section id="quick-start">
                <h2>Quick Start</h2>
                <pre><code class="language-eiffel">local
    registry: SIMPLE_TYPE_REGISTRY
    info: SIMPLE_TYPE_INFO
    reflected: SIMPLE_REFLECTED_OBJECT
    customer: CUSTOMER
do
    -- Type introspection with caching
    create registry.make
    info := registry.type_info_for ({CUSTOMER})
    print (info.name + ": " + info.field_count.out + " fields%N")

    -- Reflective field access
    create customer.make ("John", "john@example.com")
    create reflected.make (customer)
    if attached reflected.field_value ("email") as l_email then
        print ("Email: " + l_email.out + "%N")
    end
end</code></pre>
            </section>

            <section id="features">
                <h2>Features</h2>
                <ul>
                    <li>Type metadata introspection</li>
                    <li>Field read/write by name</li>
                    <li>Type info caching for performance</li>
                    <li>Type-safe enumerations</li>
                    <li>Bit flag support</li>
                    <li>Object graph traversal</li>
                    <li>Design by Contract throughout</li>
                    <li>Void-safe implementation</li>
                    <li>SCOOP-compatible</li>
                </ul>
            </section>

            <section id="api-reference">
                <h2>API Reference</h2>

                <h3>SIMPLE_TYPE_REGISTRY</h3>
                <p>Global cache for type metadata. Use this as the entry point for type introspection.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>make</code></td>
                            <td>Create empty registry</td>
                        </tr>
                        <tr>
                            <td><code>type_info_for (a_type_id: INTEGER)</code></td>
                            <td>Get cached type info for type ID</td>
                        </tr>
                        <tr>
                            <td><code>has_type (a_type_id: INTEGER)</code></td>
                            <td>Check if type is cached</td>
                        </tr>
                        <tr>
                            <td><code>clear_cache</code></td>
                            <td>Clear all cached type info</td>
                        </tr>
                    </tbody>
                </table>

                <h3>SIMPLE_TYPE_INFO</h3>
                <p>Container for type metadata including name, fields, and features.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>make_from_type_id (a_type_id: INTEGER)</code></td>
                            <td>Create from runtime type ID</td>
                        </tr>
                        <tr>
                            <td><code>name</code></td>
                            <td>Full type name with generics</td>
                        </tr>
                        <tr>
                            <td><code>base_name</code></td>
                            <td>Type name without generics</td>
                        </tr>
                        <tr>
                            <td><code>fields</code></td>
                            <td>List of field metadata</td>
                        </tr>
                        <tr>
                            <td><code>has_field (a_name)</code></td>
                            <td>Check field exists</td>
                        </tr>
                    </tbody>
                </table>

                <h3>SIMPLE_REFLECTED_OBJECT</h3>
                <p>Wraps any object for reflective access to its fields.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>make (a_object: ANY)</code></td>
                            <td>Wrap object for reflection</td>
                        </tr>
                        <tr>
                            <td><code>type_info</code></td>
                            <td>Get type metadata</td>
                        </tr>
                        <tr>
                            <td><code>field_value (a_name)</code></td>
                            <td>Read field value by name</td>
                        </tr>
                        <tr>
                            <td><code>set_field_value (a_name, a_value)</code></td>
                            <td>Write field value by name</td>
                        </tr>
                    </tbody>
                </table>

                <h3>SIMPLE_ENUMERATION</h3>
                <p>Base class for type-safe enumerations with name/value mapping.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>value</code></td>
                            <td>Current enumeration value</td>
                        </tr>
                        <tr>
                            <td><code>set_value (a_value: INTEGER)</code></td>
                            <td>Set from integer</td>
                        </tr>
                        <tr>
                            <td><code>set_from_name (a_name)</code></td>
                            <td>Set from string name</td>
                        </tr>
                        <tr>
                            <td><code>name</code></td>
                            <td>Name of current value</td>
                        </tr>
                    </tbody>
                </table>

                <h3>SIMPLE_OBJECT_GRAPH_WALKER</h3>
                <p>Traverses object references using visitor pattern.</p>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>make</code></td>
                            <td>Create walker</td>
                        </tr>
                        <tr>
                            <td><code>walk (a_root, a_visitor)</code></td>
                            <td>Traverse from root object</td>
                        </tr>
                        <tr>
                            <td><code>set_max_depth (a_depth)</code></td>
                            <td>Limit traversal depth</td>
                        </tr>
                        <tr>
                            <td><code>visited_count</code></td>
                            <td>Objects visited in last walk</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section id="installation">
                <h2>Installation</h2>
                <p>Add to your ECF file:</p>
                <pre><code class="language-xml">&lt;library name="simple_reflection" location="$SIMPLE_LIBS/simple_reflection/simple_reflection.ecf"/&gt;</code></pre>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2026 Simple Eiffel. <a href="https://github.com/simple-eiffel">GitHub</a></p>
        </div>
    </footer>
</body>
</html>
