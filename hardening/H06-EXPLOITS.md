# H06: Construct Exploit - simple_reflection

## Date: 2026-01-19

---

## BUG 1: Object ID Collision

### BUG HYPOTHESIS
The MALFORMED_CODE in `object_id` allows two different objects to have the same identifier, causing the graph walker to skip one.

### MALFORMATION TYPE: MALFORMED_CODE

### EXPLOIT

```eiffel
test_object_id_collision_proof
        -- EXPLOIT: Two different objects get same ID
    local
        l_obj1, l_obj2: ARRAYED_LIST [INTEGER]
        l_id1, l_id2: INTEGER
        l_internal: INTERNAL
    do
        create l_obj1.make (10)
        create l_obj2.make (10)
        create l_internal
        -- Same type
        assert ("same_type", l_internal.dynamic_type (l_obj1) = l_internal.dynamic_type (l_obj2))
        -- Calculate IDs using walker's formula
        l_id1 := l_internal.dynamic_type (l_obj1) * 1000000 + l_obj1.generator.hash_code \\ 1000000
        l_id2 := l_internal.dynamic_type (l_obj2) * 1000000 + l_obj2.generator.hash_code \\ 1000000
        -- COLLISION PROVEN
        assert ("collision", l_id1 = l_id2)  -- This PASSES!
    end
```

### EXPECTED MANIFESTATION
- Type: SILENT_CORRUPTION
- Contract passes (no contract to fail)
- Domain violated: Second object skipped in traversal

### ACTUAL TEST OUTPUT
```
test_object_id_collision_proof: IDs: 1080105044, 1080105044
DOCUMENTED
```

### DOMAIN IMPACT
Object graphs with multiple same-type objects may have incomplete traversal.

---

## BUG 2: INTEGER_64 Crash in set_value

### BUG HYPOTHESIS
The MALFORMED_CODE in `set_value` crashes when setting INTEGER_64 fields because the type dispatch falls through to `set_reference_field` which rejects expanded types.

### MALFORMATION TYPE: MALFORMED_CODE

### EXPLOIT

```eiffel
test_set_value_unsupported_type
        -- EXPLOIT: INTEGER_64 causes INTERNAL crash
    local
        l_test: TEST_SIMPLE_OBJECT
        l_reflected: SIMPLE_REFLECTED_OBJECT
    do
        create l_test.make ("test", 0)
        l_test.set_big_value (9223372036854775807)
        create l_reflected.make (l_test)
        -- This CRASHES
        l_reflected.set_field_value ("big_value", {INTEGER_64} 123)
    end
```

### EXPECTED MANIFESTATION
- Type: CRASH
- INTERNAL.set_reference_field precondition violated
- Stack trace shows fall-through to reference handler for expanded type

### ACTUAL TEST OUTPUT
```
test_set_value_unsupported_type: BUG CONFIRMED (INT64 crashes)
```

### DOMAIN IMPACT
Cannot use reflection to set INTEGER_64, NATURAL_*, REAL_32 fields without crash.

---

## BUG 3: Invalid type_id Accepted

### BUG HYPOTHESIS
The MALFORMED_CONTRACT in `type_info_for_type_id` accepts invalid type IDs that should be rejected.

### MALFORMATION TYPE: MALFORMED_CONTRACT (TOO WEAK)

### EXPLOIT

```eiffel
test_type_id_boundary_invalid
        -- EXPLOIT: Invalid type_id passes precondition
    local
        l_registry: SIMPLE_TYPE_REGISTRY
        l_info: SIMPLE_TYPE_INFO
    do
        create l_registry.make
        -- 999999999 passes precondition (> 0)
        l_info := l_registry.type_info_for_type_id (999999999)
        -- Should have crashed but didn't
    end
```

### EXPECTED MANIFESTATION
- Type: CRASH (expected) or SILENT_CORRUPTION (observed)
- Expected INTERNAL.type_name_of_type to fail
- Observed: No exception thrown

### ACTUAL TEST OUTPUT
```
test_type_id_boundary_invalid: UNEXPECTED (no exception)
```

### DOMAIN IMPACT
- INTERNAL apparently returns some default for invalid type_ids
- Result may be garbage type info
- Need further investigation

---

## EXPLOITS SUMMARY

| Bug | Malformation | Exploit Status | Severity |
|-----|--------------|----------------|----------|
| object_id collision | MALFORMED_CODE | CONFIRMED | HIGH |
| INTEGER_64 crash | MALFORMED_CODE | CONFIRMED | HIGH |
| invalid type_id | MALFORMED_CONTRACT | PARTIAL | MEDIUM |

---

## VERIFICATION CHECKPOINT

- Exploits constructed: 3
- Exploits confirmed: 2 fully, 1 partial
- Crashes reproduced: 1
- Silent corruption proven: 1
- hardening/H06-EXPLOITS.md: CREATED
